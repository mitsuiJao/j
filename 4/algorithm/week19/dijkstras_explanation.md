# ダイクストラ法の解説

このドキュメントでは、ダイクストラ法を実装したCプログラム `dijkstras.c` について解説します。

## 概要

このプログラムは、ダイクストラ法を使用して、グラフ内の始点から他のすべての頂点への最短経路を求めます。グラフは隣接行列で表現されています。

## アルゴリズムの解説：ダイクストラ法 (Dijkstra's Algorithm)

ダイクストラ法は、グラフ上の1つの頂点（始点）から他のすべての頂点への**最短経路**を求めるアルゴリズムです。エッジの重みが非負であるグラフに適用できます。

**基本的な手順:**
1.  **初期化:** 始点への距離を0、それ以外の頂点への距離を無限大とします。すべての頂点を「未訪問」とします。
2.  **頂点の選択:** 未訪問の頂点の中から、始点からの距離が最小の頂点を選び、「訪問済み」とします。
3.  **距離の更新（緩和）:** 選ばれた頂点に隣接する未訪問の頂点について、現在の距離よりも、選ばれた頂点を経由した方が距離が短くなる場合は、距離を更新します。
4.  **繰り返し:** すべての頂点が訪問済みになるか、到達可能な頂点がなくなるまで、手順2と3を繰り返します。

**特徴:**
-   **貪欲法:** 各ステップでその時点で最適な選択（最小距離の頂点）を行うことで、最終的な最適解に到達します。
-   **非負の重み:** エッジの重みが負の場合、正しく動作しません（その場合はベルマン・フォード法などを使用します）。
-   **応用:** カーナビの経路探索、ネットワークのルーティングなどで広く利用されています。

## 主な構成要素

### 1. 変数

-   `int n`: 頂点数。
-   `int e[n][n]`: エッジの重みを表す隣接行列。`e[i][j]` は `i` から `j` へのエッジの重みです。
-   `int D[n]`: 始点から各頂点への最短距離を格納する配列。`-1` は無限大（到達不能）を表します。
-   `int S[n]`: 訪問済み（確定済み）の頂点を記録する配列。`1` は訪問済み、`0` は未訪問を意味します。
-   `int s`: 始点の頂点。

### 2. 初期化

-   `n` と隣接行列 `e` を読み込みます。
-   始点 `s` を読み込みます。
-   `D`（距離）配列をすべての頂点について `-1`（無限大）に初期化します。
-   `S`（訪問）配列をすべての頂点について `0`（未訪問）に初期化します。
-   始点への距離 `D[s]` を `0` に設定します。

### 3. メインループ (ダイクストラ法のロジック)

アルゴリズムは `n` 回（またはすべての到達可能な頂点が訪問されるまで）繰り返されます。

1.  **最小距離の頂点を見つける:**
    -   すべての頂点 `v` を反復処理します。
    -   未訪問の頂点 (`S[v] == 0`) の中で、仮の距離 (`D[v]`) が最小のものを選択します。
    -   到達可能な未訪問頂点が見つからない場合、ループを終了します。
    -   選択された頂点を `k` とします。

2.  **訪問済みとしてマーク:**
    -   選択された頂点 `k` を訪問済みとしてマークします (`S[k] = 1`)。

3.  **緩和 (隣接頂点の更新):**
    -   `k` のすべての隣接頂点 `j` を反復処理します。
    -   隣接頂点 `j` が未訪問で、かつ `k` から `j` へのエッジが存在する場合 (`e[k][j] != 0`):
        -   新しい距離の候補を計算します: `new_dist = D[k] + e[k][j]`。
        -   `j` への現在の距離が無限大 (`D[j] == -1`) であるか、`new_dist` が既存の `D[j]` より小さい場合:
            -   `D[j]` を `new_dist` に更新します。

### 4. 出力

-   プログラムは、始点から各頂点への最短距離を `頂点インデックス 距離` の形式で出力します。

## 入出力形式

**入力:**
-   1行目：整数 `n`（頂点数）。
-   続く `n` 行：各行 `n` 個の整数、隣接行列 `e` を表します。
-   最終行：整数 `s`（始点）。

**出力:**
-   複数行。各行に2つの整数：頂点のインデックスと始点からの最短距離。
