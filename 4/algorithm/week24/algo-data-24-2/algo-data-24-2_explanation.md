# KMPアルゴリズムの解説

このドキュメントでは、クヌース・モリス・プラット（KMP）文字列探索アルゴリズムを実装したCプログラム `algo-data-24-2.c` について解説します。

## 概要

このプログラムは、テキスト文字列内にパターン文字列が存在するかどうかを確認します。KMPアルゴリズムを使用して、パターンを前処理して不要な比較を避けることで、効率的に探索を行います。

## アルゴリズムの解説：KMP法 (Knuth-Morris-Pratt Algorithm)

KMP法は、文字列（テキスト）の中から特定のパターンを検索するための効率的なアルゴリズムです。単純な力任せの探索（Brute-force）では、不一致が起きるたびにパターンの先頭に戻って比較をやり直しますが、KMP法は**不一致が起きた時点での情報を利用**して、比較位置を適切に進める（スキップする）ことで無駄な比較を省きます。

**主なステップ:**
1.  **前処理 (Preprocessing):** パターン文字列自体を解析し、**スキップテーブル（失敗関数）**を作成します。このテーブルは、「ある位置で不一致が起きたとき、パターンのどの位置まで戻ればよいか（あるいはテキストをどれだけ進めればよいか）」を示します。これは、パターン内に繰り返し出現する部分文字列の情報を利用しています。
2.  **検索 (Matching):** テキストとパターンを比較します。
    -   文字が一致すれば、両方のインデックスを進めます。
    -   不一致が起きた場合、スキップテーブルを参照してパターンの比較位置を移動させます。テキスト側のインデックスを戻す必要がないため、効率的です。

**計算量:**
テキストの長さを $N$、パターンの長さを $M$ とすると、計算量は $O(N + M)$ となり、非常に高速です。

## 主な構成要素

### 1. `kmp_match` 関数

-   **引数:**
    -   `const char txt[]`: 探索対象のテキスト文字列。
    -   `const char pat[]`: 探索するパターン文字列。

-   **前処理（スキップテーブルの構築）:**
    -   `skip` テーブル（部分一致テーブルまたは失敗関数とも呼ばれる）を構築します。
    -   `pt` はテーブル内の位置、`pp` は一致している接頭辞の長さを追跡します。
    -   不一致が発生したときにパターンをどれだけシフトするかを決定します。
    -   `skip[pt]` は、`pt` で不一致が発生した場合にバックトラックすべきパターンのインデックスを格納します。

-   **マッチング処理:**
    -   `pt` はテキスト `txt` 内のインデックスを追跡します。
    -   `pp` はパターン `pat` 内のインデックスを追跡します。
    -   どちらかの文字列が終端 (`\0`) に達するまで反復します。
    -   **一致:** `txt[pt] == pat[pp]` の場合、両方のポインタを進めます。
    -   **不一致:**
        -   `pp == 0` の場合、`pt` のみを進めます（テキストの次の文字から確認を開始）。
        -   それ以外の場合、`pp` を `skip[pp]` にバックトラックします（事前計算されたテーブルを使用して、整列済みの文字をスキップ）。
    -   **発見:** `pat[pp] == '\0'` の場合、パターンが完全に見つかりました。関数は一致の開始インデックス `pt - pp` を返します。
    -   **未発見:** ループが終了しても完全な一致が見つからない場合、`-1` を返します。

### 2. `main` 関数

-   テキスト文字列 `txt` を読み込みます。
-   パターン文字列 `pat` を読み込みます。
-   `kmp_match` を呼び出し、結果（一致したインデックスまたは -1）を出力します。

## 入出力形式

**入力:**
-   1行目：テキスト文字列（最大1024文字）。
-   2行目：パターン文字列（最大1024文字）。

**出力:**
-   パターンがテキスト内で最初に出現する0始まりのインデックスを表す整数。
-   パターンが見つからない場合は `-1` を返します。
