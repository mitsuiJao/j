# 深さ優先探索 (DFS) の解説

このドキュメントでは、グラフの深さ優先探索 (DFS) アルゴリズムを実装したCプログラム `dfs.c` について解説します。

## 概要

このプログラムは、隣接行列で表現されたグラフ上で深さ優先探索を行います。ユーザーが指定した頂点から探索を開始し、頂点が訪問される順序を出力します。

## アルゴリズムの解説：深さ優先探索 (Depth First Search, DFS)

深さ優先探索は、グラフや木構造を探索するためのアルゴリズムの一つです。開始ノードから出発し、行き止まりになるまで可能な限り深く探索を進め、行き止まりになったら直前の分岐点まで戻って（バックトラック）、別の経路を探索します。

**特徴:**
-   **スタック（または再帰）を使用:** 探索の履歴を管理するためにスタック構造（プログラム上では再帰呼び出しによるコールスタック）を利用します。
-   **メモリ効率:** 幅優先探索（BFS）に比べて、多くの場合メモリ使用量が少なくて済みます。
-   **完全性:** 解が存在する場合、有限グラフであれば必ず解を見つけることができますが、最短経路を見つける保証はありません。
-   **用途:** 迷路の解法、連結成分の検出、トポロジカルソートなどに利用されます。

## 主な構成要素

### 1. `dfs` 関数

探索を実行する再帰関数です。

- **引数:**
    - `int u`: 現在訪問中の頂点（0始まりのインデックス）。
    - `int n`: 頂点の総数。
    - `int matrix[n][n]`: グラフを表す隣接行列。`matrix[u][i] == 1` は、頂点 `u` と頂点 `i` の間にエッジがあることを意味します。
    - `int C[n]`: 訪問済みの頂点を記録する配列。`C[i] == 1` は、頂点 `i` が訪問済みであることを意味します。

- **ロジック:**
    1.  現在の頂点 `u` を訪問済みとしてマークします (`C[u] = 1`)。
    2.  現在の頂点 `u + 1` を出力します（出力用に1始まりのインデックスに戻します）。
    3.  すべての隣接可能な頂点 `i` （0 から `n-1`）について反復処理を行います。
    4.  `u` から `i` へのエッジが存在し (`matrix[u][i] == 1`)、かつ頂点 `i` が未訪問の場合 (`C[i] == 0`)、頂点 `i` に対して `dfs` を再帰的に呼び出します。

### 2. `main` 関数

-   **入力読み込み:**
    -   頂点数 `n` を読み込みます。
    -   隣接行列 `matrix[n][n]` を読み込みます。
    -   開始頂点 `S` を読み込みます。

-   **初期化:**
    -   訪問配列 `C` をすべて0（未訪問）で初期化します。

-   **実行:**
    -   頂点 `S-1` （1始まりの入力を0始まりのインデックスに変換）から `dfs` を呼び出します。

-   **出力:**
    -   訪問された順序で頂点を出力します。
    -   最後に改行を出力します。

## 入出力形式

**入力:**
-   1行目：整数 `n`（頂点数）。
-   続く `n` 行：各行 `n` 個の整数（0 または 1）、隣接行列を1行ずつ表します。
-   最終行：整数 `S`（開始頂点、1始まり）。

**出力:**
-   訪問された頂点の順序を表すスペース区切りの整数。
