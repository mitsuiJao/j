# ナップサック問題の解説

このドキュメントでは、動的計画法（DP）を使用して0/1ナップサック問題を解くCプログラム `algo-data-22-1.c` について解説します。

## 概要

このプログラムは、容量が固定されたナップサックに含めることができるアイテムの価値の最大合計を求めます。動的計画法のアプローチを使用して、部分問題の最適値のテーブルを作成します。

## アルゴリズムの解説：動的計画法 (Dynamic Programming, DP)

動的計画法は、問題を複数の部分問題に分割し、それぞれの部分問題の解を記録（メモ化）しながら、最終的な問題の解を求める手法です。

**0/1 ナップサック問題での適用:**
-   **問題:** 重さと価値が決まっている $N$ 個のアイテムと、最大容量 $W$ のナップサックがあります。容量を超えない範囲で、価値の合計を最大にするアイテムの組み合わせを求めます（アイテムは分割できません）。
-   **DPテーブル:** 2次元配列 `T[i][j]` を使用します。これは、「最初の $i$ 個のアイテムのみを考慮し、ナップサックの容量が $j$ のときの最大価値」を表します。
-   **漸化式:**
    -   アイテム $i$ を入れない場合: `T[i-1][j]`
    -   アイテム $i$ を入れる場合（容量が許せば）: `T[i-1][j - weight[i]] + value[i]`
    -   `T[i][j]` は上記2つの大きい方の値をとります。

**特徴:**
-   **最適性原理:** 問題の最適解が、その部分問題の最適解から構成される性質を利用します。
-   **重複する部分問題:** 同じ部分問題を何度も解くことを防ぐため、計算結果を再利用します。これにより、指数関数的な計算時間を多項式時間に短縮できる場合があります。

## 主な構成要素

### 1. 定数とデータ構造

-   `N`: アイテムの数（10に設定）。
-   `CAPACITY`: ナップサックの最大容量（50に設定）。
-   `typedef struct Cell`:
    -   `value`: ある状態における達成可能な最大価値。
    -   `history`: どのアイテムが含まれているかを追跡するためのビットマスク（ただし、最終的な出力には明示的に使用されていません）。

### 2. 変数

-   `int W[N + 1]`: 各アイテムの重さを格納（1始まり）。
-   `int V[N + 1]`: 各アイテムの価値を格納（1始まり）。
-   `Cell T[N + 1][CAPACITY + 1]`: DPテーブル。`T[i][j]` は、最初の `i` 個のアイテムを考慮し、ナップサック容量が `j` の場合の最適解を格納します。

### 3. ロジック

1.  **入力:** `N` 個のアイテムの価値と重さを読み込みます。
2.  **初期化:** DPテーブル `T` を0で初期化します。
3.  **DPループ:**
    -   各アイテム `i` （1から `N` まで）について反復します。
    -   各容量 `j` （1から `CAPACITY` まで）について反復します。
    -   **決定:**
        -   現在のアイテムの重さ `W[i]` が現在の容量 `j` 以下の場合:
            -   `v1` を計算: アイテム `i` を含める場合の価値（アイテム `i` の価値 + 残り容量 `j - W[i]` での最適価値）。
            -   `v2` を計算: アイテム `i` を含めない場合の価値（以前の `i-1` 個のアイテムで容量 `j` の場合の最適価値）。
            -   `T[i][j].value` を `v1` と `v2` の大きい方で更新します。
        -   アイテムの重さが容量 `j` より大きい場合:
            -   アイテムを含めることはできないため、`T[i][j]` は `T[i-1][j]` と同じになります。

### 4. 出力

-   `N` 個すべてのアイテムを考慮し、容量が `CAPACITY` のときに達成可能な最大価値（`T[N][CAPACITY].value`）を出力します。

## 入出力形式

**入力:**
-   `N` 行。各行に2つの整数：アイテムの価値 `V` と重さ `W`。

**出力:**
-   合計最大価値を表す1つの整数。
