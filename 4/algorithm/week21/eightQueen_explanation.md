# エイト・クイーン問題の解説

このドキュメントでは、エイト・クイーン問題をバックトラック法で解くCプログラム `eightQueen.c` について解説します。

## 概要

このプログラムは、$8 \times 8$ のチェス盤上に、お互いに取り合わないように8個のクイーンを配置するすべての方法を見つけます。つまり、どの2つのクイーンも同じ行、列、または対角線上に存在しないように配置します。

## アルゴリズムの解説：バックトラック法 (Backtracking)

バックトラック法は、制約充足問題などを解くために用いられる探索アルゴリズムです。解の候補を少しずつ構築していき、それが解になり得ないとわかった時点で、直前の手順まで戻って（バックトラックして）別の候補を試します。

**エイト・クイーン問題での適用:**
1.  **配置:** 1列目から順にクイーンを置いていきます。
2.  **制約チェック:** クイーンを置く際、既存のクイーンと取り合いにならないか（同じ行、列、対角線上にないか）を確認します。
3.  **再帰:** 安全に置ける場所があれば、そこにクイーンを置き、次の列に進みます。
4.  **バックトラック:** 安全に置ける場所がない場合、あるいはすべての解を見つけた後、一つ前の列に戻り、クイーンの位置を変更して再試行します。

**特徴:**
-   **深さ優先探索の一種:** 可能な限り深く探索し、行き止まりで戻るという点でDFSと似ています。
-   **枝刈り (Pruning):** 明らかに解にならない部分探索木を早期に切り捨てることで、全探索よりも効率的に解を見つけます。

## 主な構成要素

### 1. グローバル配列（フラグ）

-   `int flg_a[8]`: 列（縦）の使用状況を追跡します。`flg_a[j] = 1` は、列 `j` にクイーンが置かれていることを意味します。
-   `int flg_b[15]`: 右下がり対角線（左上から右下）の使用状況を追跡します。インデックスは `i + j` で計算されます。
-   `int flg_c[15]`: 左下がり対角線（右上から左下）の使用状況を追跡します。インデックスは `i - j + 7` で計算されます。
-   `int pos[8]`: 各行におけるクイーンの位置を保存します。`pos[i] = j` は、行 `i` のクイーンが列 `j` にあることを意味します。

### 2. `set` 関数 (バックトラック)

行 `i` にクイーンを配置しようとする再帰関数です。

-   **ロジック:**
    -   すべての列 `j` （0から7まで）を反復処理します。
    -   **安全確認:** `flg_a`, `flg_b`, `flg_c` がすべて0であることを確認し、`(i, j)` にクイーンを置くのが安全かどうかをチェックします。
    -   安全な場合:
        -   解決位置を記録します: `pos[i] = j`。
        -   **基本ケース:** `i == 7` （最後の行）の場合、解が見つかったことになります。`print()` を呼び出して盤面を表示します。
        -   **再帰ステップ:**
            -   列と対角線を使用中としてマークします（`flg_a`, `flg_b`, `flg_c` を1に設定）。
            -   次の行にクイーンを置くために `set(i + 1)` を再帰的に呼び出します。
            -   **バックトラック:** 他の可能性を探索するために、列と対角線のマークを解除します（フラグを0に戻します）。

### 3. `print` 関数

-   $8 \times 8$ の盤面構成を表示します。
-   `1` はクイーン、`0` は空きマスを表します。
-   解の番号（`counter`）を表示します。

### 4. `main` 関数

-   すべてのフラグ配列を0に初期化します。
-   `set(0)` を呼び出して処理を開始します。

## 出力

プログラムは、エイト・クイーン問題のすべての異なる解を出力します。各解について、盤面のレイアウトと通し番号が表示されます。
